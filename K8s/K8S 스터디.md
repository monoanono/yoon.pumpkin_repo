# K8S 스터디

  - 참고 :  Minikube 활용 K8s 스터디
    - https://subicura.com/k8s/prepare/
    - https://subicura.com/k8s/guide/#%E1%84%80%E1%85%A1%E1%84%8B%E1%85%B5%E1%84%83%E1%85%B3


### 내용 정리

![Image](https://github.com/user-attachments/assets/09d891dc-7f62-4ac9-b63a-6328c2ed7d5b)

![Image](https://github.com/user-attachments/assets/8aade5ae-3c11-4c24-85c3-787a76c621aa)

![Image](https://github.com/user-attachments/assets/d86fd417-52a9-4d06-ac5b-60e1905216eb)

<img width="2048" height="2732" alt="Image" src="https://github.com/user-attachments/assets/4561fb31-2a80-4331-b625-2e72372bdc6a" />

<img width="2048" height="2732" alt="Image" src="https://github.com/user-attachments/assets/25e7baf3-6c17-476f-8ab1-c9c3be7e95e7" />

<img width="1469" height="1207" alt="Image" src="https://github.com/user-attachments/assets/5b4f7046-f01c-408a-a0e4-919407dbca99" />

<img width="1410" height="1401" alt="Image" src="https://github.com/user-attachments/assets/3f46b6f8-5ba6-4dfc-a42e-c6e067b4ef90" />

	• kubectl 과 minikube 실행 주체 및 동작 원리
	kubectl과 minikube 명령어의 실행 주체 및 동작 원리
	1. kubectl 명령어:
		• 실행 주체: kubectl은 사용자의 로컬 컴퓨터(여기서는 Windows 환경)에서 실행됩니다.
		• 동작 원리:
			○ kubectl은 Kubernetes 클러스터의 API 서버와 통신하는 CLI 도구입니다.
			○ 사용자가 kubectl 명령어를 실행하면, 이 명령어는 API 서버로 HTTP 요청을 보내 클러스터 리소스를 관리합니다.
			○ API 서버는 요청을 받아 처리하고, 필요한 경우 클러스터의 상태 데이터를 저장하는 etcd에 접근합니다.
			○ kubectl은 클러스터 내부의 Pod, Service, Deployments 등과 같은 리소스를 제어할 수 있습니다.
	2. minikube 명령어:
		• 실행 주체: minikube도 사용자의 로컬 컴퓨터에서 실행됩니다.
		• 동작 원리:
			○ minikube는 로컬 컴퓨터에서 단일 노드 Kubernetes 클러스터를 실행할 수 있게 해주는 도구입니다.
			○ minikube start 명령어를 실행하면, Hyper-V, VirtualBox 등과 같은 가상화 기술을 이용해 가상 머신을 생성하고, 그 안에 Kubernetes 클러스터를 띄웁니다.
			○ 이 가상 머신은 마스터 노드와 워커 노드를 포함한 단일 노드 클러스터로 동작합니다.
			○ minikube 명령어는 이 가상 머신에서 실행 중인 Kubernetes 클러스터를 제어하거나 상태를 조회하는 데 사용됩니다.
	구동 흐름 및 동작 원리 요약:
		1. minikube 구동:
			○ minikube start 명령어를 통해 Hyper-V와 같은 가상화 환경에서 Kubernetes 클러스터가 생성됩니다.
			○ 이 가상 머신은 Kubernetes의 마스터 노드와 워커 노드를 모두 포함한 단일 노드로 동작합니다.
		2. kubectl 사용:
			○ 클러스터가 구동되면, kubectl을 사용하여 클러스터 내부의 리소스(Pod, Service 등)를 제어합니다.
			○ kubectl은 사용자의 로컬 컴퓨터에서 실행되어 Hyper-V에서 구동 중인 가상 머신 내의 Kubernetes API 서버와 통신합니다.
			○ API 서버는 명령을 처리하고, 클러스터의 상태를 반영하도록 etcd를 업데이트합니다.
	구동 흐름을 시각적으로 표현한 그림:
	
	
	
	[Windows (로컬 컴퓨터)]                           [Hyper-V (가상 머신 내)]
+-------------------+                                +----------------------+
|  kubectl 명령어     |    <--API 호출-->      | Kubernetes API 서버 |
|  minikube 명령어  |                                 |      (마스터 노드)      |
+-------------------+                                |                                    |
                                                                  |             etcd             |
                                                                  |      (상태 저장소)     |
                                                                  +----------------------+
		• Windows 환경: 사용자는 kubectl과 minikube 명령어를 로컬 컴퓨터에서 실행합니다.
		• Hyper-V 가상 머신: minikube가 생성한 가상 머신에서 Kubernetes 클러스터가 동작하며, kubectl 명령어는 이 클러스터의 API 서버와 통신합니다.
	요약
		• kubectl과 minikube 모두 로컬 컴퓨터에서 실행되며, 각기 다른 역할을 합니다.
			○ kubectl: Kubernetes 클러스터의 API 서버와 통신하여 클러스터 리소스를 관리.
			○ minikube: 로컬에서 Kubernetes 클러스터를 실행하고 관리하기 위한 도구.
		• minikube는 Hyper-V를 통해 가상 머신을 생성하고, 그 안에서 Kubernetes 클러스터를 구동합니다. kubectl은 이 클러스터를 제어하는 데 사용됩니다.
	
	
	
	• Istio
	Istio는 클라우드 네이티브 애플리케이션에서 서비스 간 통신을 관리하고 보호하기 위해 개발된 서비스 메시(Service Mesh) 기술입니다. Istio는 마이크로서비스 아키텍처에서 각 서비스 간의 통신을 추상화하여 관리하고, 보안, 트래픽 관리, 모니터링 및 정책 관리를 제공합니다.
	주요 개념 및 기능:
		1. 서비스 메시(Service Mesh):
			○ 서비스 메시는 마이크로서비스 간의 네트워크 통신을 제어하고 관찰하기 위한 인프라 계층입니다. Istio는 이러한 서비스를 서로 연결하고, 통신을 관리하는 데 사용됩니다.
		2. 트래픽 관리:
			○ Istio는 서비스 간의 트래픽을 세밀하게 제어할 수 있는 기능을 제공합니다. 이를 통해 로드 밸런싱, 트래픽 분할(예: A/B 테스트, 카나리아 배포), 라우팅(예: 버전별 라우팅) 등을 손쉽게 구현할 수 있습니다.
			○ 서킷 브레이커, 리트라이, 타임아웃 등의 기능을 통해 서비스의 복원력(resilience)을 강화합니다.
		3. 보안:
			○ Istio는 서비스 간의 통신을 mTLS(Mutual TLS)를 사용해 암호화하여 안전한 통신을 보장합니다.
			○ 서비스 간의 인증 및 권한 부여를 관리하여, 올바른 권한을 가진 서비스만이 통신할 수 있도록 합니다.
		4. 관찰성(Observability):
			○ Istio는 서비스 간의 트래픽, 요청, 오류, 지연 시간 등을 모니터링하고 추적하는 기능을 제공합니다.
			○ Istio는 Prometheus, Grafana, Jaeger와 같은 도구와 통합하여 메트릭, 로그, 트레이싱 데이터를 수집하고 시각화할 수 있습니다.
		5. 정책 관리:
			○ Istio는 서비스 간의 통신에 대한 정책을 설정하고 적용할 수 있습니다. 예를 들어, 특정 서비스의 호출 제한, 트래픽 제어, 접근 제어 정책 등을 정의할 수 있습니다.
	Istio의 구성 요소:
		1. Envoy Proxy:
			○ Istio의 핵심 구성 요소로, 각 서비스의 사이드카(Sidecar)로 배포됩니다.
			○ 서비스 간의 모든 트래픽은 Envoy 프록시를 통해 전달되며, 트래픽을 제어하고 보안을 적용합니다.
		2. Pilot:
			○ Envoy 프록시에 라우팅 규칙을 전파하여 트래픽 관리를 제어합니다.
			○ Istio의 제어 평면(Control Plane)의 중요한 구성 요소로, 네트워크 트래픽에 대한 지능적인 라우팅을 담당합니다.
		3. Citadel:
			○ 서비스 간의 mTLS 기반 보안을 위한 인증서 발급과 관리를 담당합니다.
			○ 서비스 간의 인증, 권한 부여, 암호화된 통신을 지원합니다.
		4. Galley:
			○ 구성 검증 및 구성 데이터를 Istio의 다른 구성 요소에 배포하는 역할을 합니다.
			○ Istio의 구성 데이터를 관리하고, 오류가 없는지 확인하는 작업을 수행합니다.
		5. Mixer:
			○ 서비스 호출에 대한 텔레메트리 데이터(로그, 메트릭)를 수집하고, 정책을 평가하여 적용합니다.
			○ Istio의 정책 및 관찰성 기능을 담당합니다.
	Istio의 주요 사용 사례:
		• 마이크로서비스 간의 통신 관리: 서비스 간의 복잡한 네트워크 통신을 추상화하고 관리할 수 있습니다.
		• 트래픽 제어 및 관리: A/B 테스트, 카나리아 배포, 블루-그린 배포와 같은 배포 전략을 손쉽게 구현할 수 있습니다.
		• 보안 강화: 서비스 간의 통신을 안전하게 암호화하고, 인증 및 권한 부여를 관리할 수 있습니다.
		• 모니터링 및 관찰성 향상: 서비스 간의 통신을 추적하고 모니터링하여 시스템의 성능과 상태를 파악할 수 있습니다.
	요약:
	Istio는 클라우드 네이티브 애플리케이션에서 서비스 간 통신을 관리하고 보호하기 위한 강력한 서비스 메시 플랫폼입니다. 트래픽 관리, 보안, 관찰성, 정책 관리 기능을 통해 마이크로서비스 아키텍처의 복잡성을 줄이고, 서비스 간의 통신을 쉽게 제어할 수 있도록 도와줍니다.
	
	
	• Helm
	Helm은 Kubernetes에서 애플리케이션을 관리하고 배포하기 위한 패키지 매니저입니다. Helm을 사용하면 복잡한 Kubernetes 애플리케이션을 쉽게 정의하고 설치하며, 애플리케이션의 라이프사이클을 관리할 수 있습니다.
	Helm의 주요 개념 및 기능:
		1. Helm 차트(Helm Chart):
			○ Helm 차트는 Kubernetes 애플리케이션을 정의한 템플릿입니다. 차트는 애플리케이션을 구성하는 여러 Kubernetes 리소스(예: Deployment, Service, ConfigMap 등)를 하나의 패키지로 묶은 것입니다.
			○ 차트는 YAML 형식으로 작성된 템플릿 파일들과 그 템플릿 파일에 값을 제공하는 values.yaml 파일로 구성됩니다.
			○ 이를 통해 복잡한 애플리케이션을 재사용 가능하고, 버전 관리할 수 있는 형태로 배포할 수 있습니다.
		2. Helm 릴리스(Helm Release):
			○ Helm 릴리스는 차트를 사용하여 Kubernetes 클러스터에 애플리케이션을 설치한 인스턴스를 의미합니다.
			○ 릴리스는 설치된 애플리케이션의 특정 버전과 그 설정을 포함하며, 동일한 차트를 여러 번 설치해도 각각 별도의 릴리스로 관리됩니다.
			○ helm install 명령어를 사용해 차트를 설치하면, 그에 대한 릴리스가 생성됩니다.
		3. Helm 리포지토리(Helm Repository):
			○ Helm 리포지토리는 차트를 저장하고 공유할 수 있는 장소입니다.
			○ 공용 리포지토리(예: Artifact Hub)나 개인 리포지토리를 설정하여 차트를 공유하거나 관리할 수 있습니다.
			○ helm repo add 명령어를 통해 원하는 리포지토리를 추가하고, 그 안에 있는 차트를 검색하고 사용할 수 있습니다.
		4. 템플릿 및 값 파일:
			○ Helm 차트는 템플릿 파일과 값 파일(values.yaml)을 조합해 Kubernetes 리소스를 생성합니다.
			○ 값 파일은 템플릿에 동적으로 주입되어 각 환경에 맞는 설정을 쉽게 적용할 수 있습니다.
			○ 예를 들어, 동일한 차트로 개발, 테스트, 운영 환경에 서로 다른 설정을 적용할 수 있습니다.
	Helm의 주요 기능:
		1. 패키징 및 배포:
			○ Helm은 Kubernetes 애플리케이션을 하나의 차트로 패키징하여 쉽게 배포할 수 있도록 합니다.
			○ 차트를 사용해 여러 리소스를 일관성 있게 배포하고, 애플리케이션의 다양한 버전을 관리할 수 있습니다.
		2. 업그레이드 및 롤백:
			○ Helm은 애플리케이션의 업그레이드를 간편하게 관리할 수 있으며, 문제가 발생할 경우 손쉽게 이전 버전으로 롤백할 수 있습니다.
			○ helm upgrade와 helm rollback 명령어를 사용하여 릴리스 버전을 관리합니다.
		3. 차트 커스터마이징:
			○ values.yaml 파일을 통해 차트의 기본 설정을 쉽게 커스터마이징할 수 있습니다.
			○ 차트 템플릿 파일에서 변수와 조건문을 사용하여 동적인 리소스를 생성할 수 있습니다.
		4. 차트 저장 및 공유:
			○ Helm 리포지토리를 통해 차트를 저장하고 다른 팀이나 커뮤니티와 공유할 수 있습니다.
			○ 공개된 Helm 리포지토리에서 차트를 검색하고 설치할 수 있어, 복잡한 애플리케이션을 손쉽게 배포할 수 있습니다.
	Helm의 주요 사용 사례:
		• 애플리케이션 배포: 복잡한 애플리케이션을 쉽게 패키징하여 Kubernetes 클러스터에 배포할 수 있습니다.
		• 버전 관리: 애플리케이션의 다양한 버전을 Helm 릴리스로 관리하고, 필요한 경우 롤백할 수 있습니다.
		• 구성 관리: 환경별로 다른 설정을 적용하여 동일한 애플리케이션을 다양한 환경에서 배포하고 운영할 수 있습니다.
		• CI/CD 파이프라인 통합: Helm을 CI/CD 파이프라인에 통합하여 애플리케이션 배포를 자동화하고 관리할 수 있습니다.
	요약:
	Helm은 Kubernetes의 애플리케이션 패키지 매니저로, Kubernetes 리소스들을 템플릿화하여 관리하고, 쉽게 배포 및 업그레이드할 수 있도록 돕는 도구입니다. 복잡한 애플리케이션의 배포와 관리를 단순화하고, 버전 관리 및 환경별 설정을 유연하게 처리할 수 있습니다.
	
	
	• Kafka
	Apache Kafka는 분산형 스트리밍 플랫폼으로, 실시간으로 데이터를 수집, 저장, 처리하는 데 최적화된 오픈 소스 소프트웨어입니다. Kafka는 대규모 데이터 스트리밍을 처리할 수 있는 기능을 제공하며, 메시지 큐(Messaging Queue)와 분산 로그(Distributed Log)의 역할을 모두 수행할 수 있습니다.
	Kafka의 주요 개념:
		1. 프로듀서(Producer):
			○ 프로듀서는 Kafka로 데이터를 전송하는 클라이언트입니다. 애플리케이션, 서비스 또는 센서 등이 프로듀서 역할을 할 수 있으며, 데이터를 특정 **토픽(Topic)**으로 보냅니다.
		2. 토픽(Topic):
			○ 토픽은 Kafka에서 데이터를 분류하고 저장하는 카테고리입니다.
			○ 각 토픽은 **파티션(Partition)**으로 나뉘며, 파티션은 데이터의 실제 저장 단위입니다. 파티션 내에서 데이터는 순서대로 저장되며, 각 메시지는 오프셋(Offset)이라고 불리는 고유 번호를 가집니다.
		3. 컨슈머(Consumer):
			○ 컨슈머는 Kafka에서 데이터를 읽어들이는 클라이언트입니다. 컨슈머는 특정 토픽의 데이터를 구독(subscribe)하고, 프로듀서가 전송한 메시지를 순차적으로 처리합니다.
		4. 브로커(Broker):
			○ 브로커는 Kafka 클러스터를 구성하는 서버로, 토픽의 데이터를 저장하고 관리하는 역할을 합니다.
			○ 하나의 Kafka 클러스터는 여러 개의 브로커로 구성될 수 있으며, 이들은 서로 협력하여 대규모 데이터를 분산 처리합니다.
		5. 파티션(Partition):
			○ 각 토픽은 하나 이상의 파티션으로 나뉘며, 파티션 내의 데이터는 순서대로 기록됩니다. 파티션을 사용하면 데이터의 병렬 처리가 가능해집니다.
		6. 리플리케이션(Replication):
			○ Kafka는 데이터의 가용성과 내구성을 보장하기 위해 각 파티션의 데이터를 복제(replication)합니다. 기본적으로 한 파티션은 여러 브로커에 복제되어 저장됩니다.
		7. ZooKeeper:
			○ Kafka는 ZooKeeper를 통해 브로커 간의 메타데이터 관리와 클러스터 관리를 수행합니다. ZooKeeper는 Kafka 클러스터의 구성 정보와 상태를 유지합니다.
	Kafka의 주요 기능:
		1. 실시간 데이터 스트리밍:
			○ Kafka는 대량의 데이터를 실시간으로 수집하고 스트리밍할 수 있습니다. 이는 로그 수집, 이벤트 스트리밍, 실시간 분석 등 다양한 분야에서 활용됩니다.
		2. 내구성 및 신뢰성:
			○ Kafka는 데이터를 디스크에 내구성 있게 저장하며, 리플리케이션을 통해 장애가 발생해도 데이터 손실을 최소화합니다.
		3. 확장성:
			○ Kafka는 브로커와 파티션을 추가함으로써 수평적으로 확장할 수 있습니다. 이 확장성 덕분에 Kafka는 수천 대의 브로커와 수백만 개의 메시지를 처리할 수 있습니다.
		4. 고성능:
			○ Kafka는 높은 처리량과 낮은 지연 시간을 제공하도록 설계되었습니다. 이는 많은 양의 데이터를 빠르고 효율적으로 처리할 수 있음을 의미합니다.
		5. 구독/발행 모델:
			○ Kafka는 구독/발행(Pub/Sub) 모델을 사용하여 데이터를 프로듀서와 컨슈머 간에 비동기적으로 전달합니다. 이 모델은 데이터의 실시간 처리와 여러 컨슈머 그룹이 동시에 데이터를 처리할 수 있는 환경을 제공합니다.
	Kafka의 사용 사례:
		1. 로그 및 이벤트 수집:
			○ Kafka는 애플리케이션 로그, 시스템 로그, 사용자 이벤트 데이터를 수집하고 중앙화된 장소로 전송하는 데 자주 사용됩니다.
		2. 실시간 분석:
			○ Kafka는 실시간으로 데이터를 처리하고 분석하는 시스템의 핵심 구성 요소로 사용될 수 있습니다. 예를 들어, 실시간 사용자 행동 분석, 실시간 거래 모니터링 등이 가능합니다.
		3. 데이터 파이프라인:
			○ Kafka는 서로 다른 데이터 시스템 간에 데이터를 이동시키는 데이터 파이프라인으로 사용할 수 있습니다. 이는 데이터베이스, 데이터 웨어하우스, 분석 시스템 등으로 데이터를 스트리밍하는 데 유용합니다.
		4. 메시징 시스템:
			○ Kafka는 전통적인 메시지 큐 시스템 대신 사용될 수 있으며, 여러 서비스 간의 메시지 전달을 고도로 확장 가능하고 신뢰성 있게 처리할 수 있습니다.
	요약:
	Apache Kafka는 대규모 데이터를 실시간으로 스트리밍, 처리, 저장할 수 있는 강력한 분산형 플랫폼입니다. 높은 처리 성능, 확장성, 내구성을 갖춘 Kafka는 로그 수집, 실시간 분석, 데이터 파이프라인 등 다양한 분야에서 활용되며, 현대의 데이터 중심 애플리케이션을 지원하는 핵심 기술 중 하나입니다.
